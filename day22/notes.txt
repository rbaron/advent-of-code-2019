# Simple modular linear congruence

y = x + 2 (mod 5)

y(0) = 2
y(1) = 3
y(2) = 4
y(3) = 0
y(4) = 1
y(5) = 2
y(6) = 3
y(7) = 4
y(8) = 0
y(9) = 1
...

In our case, we have (for the `cut` method): y(position) = (position - (n + size)) (mod size)

## Inverting

# Modular arithmetic satisfies some of the same properties as "regular" arithmetic
(https://en.wikipedia.org/wiki/Modular_arithmetic#Properties), specially "compatibility
with addition/subtraction", which lets us invert congruences like y = x + a (mod N) by
subtracting `a` from both sides:

x = y - a (mod N)

Particularly:
x = y - 2 (mod 5)
x(0) = -2 = 3*
x(1) = -1 = 4
x(2) = 0
x(3) = 1
x(4) = 2
x(5) = 3
x(6) = 4
x(7) = 0
x(8) = 1

* Negative numbers: in (mod N) world, we are free to add `N` to a number infinitely, and the result
will still be congruent with the original value. For example in (mod 5):
-1 + 5 = 4 + 5 =  9 + 5 = 14 + 5 = 4 (mod 5)

In our case, both `cut` and `deal_with_new_stack` have this shape, so we know how to invert
them.

# Multiplicative congruences

What about congruences in the shape of y = 3x (mod 5)?

y(0) = 0
y(1) = 3
y(2) = 1
y(3) = 4
y(4) = 2
y(5) = 0
y(6) = 3
y(7) = 1
...

In "regular" math, we can find the inverse of `y = 3x` by dividing both sides by 3:

x = 1/3 * y

Interestingly, if we take all the values that `a (mod 5)` can take, we find that
the only possible values for `a` (bar congruences, which amount to the same) are:

{0, 1, 2, 3, 4}

There are no fractional values like 1/3, so regular inversion does not work. What works is,
as in "regular" math, finding a value `b` such that:

a * b = 1

In particular, if we are interested in finding the inverse of:

y = 3x (mod 5)

We need to find b such that:

3 * b = 1

If we have this value `b`, we can multiply both sides by it:

by = b3x = 1x (mod 5)
=> x = by (mod 5)

### Questions

#### Does such b always exist?

https://en.wikipedia.org/wiki/Modular_multiplicative_inverse#Multiplicative_group_of_integers_modulo_m

Apparently the multiplicative inverse of `a (mod N)` exists if `N` and `a` are relatively prime. This is
always the case when `N` itself is prime.

#### What if a == 0?

## How do we find b (the "multiplicative inverse")?

One approach is to use the Extended Euclidean Algorithm.
(https://en.wikipedia.org/wiki/Modular_multiplicative_inverse#Extended_Euclidean_algorithm):

To find the inverse of `a (mod N)`, we can solve the equation:

ax + yN = 1

If we find x and y, the term yN = 0 (since everything is (mod N)), and we get:
ax + yN = 1

=> ax = 1

`x` is the multiplicative inverse, exactly like we wanted.

* Note that is N is small, we can precompute a table of inverses by doing only the "forward" multiplication.
This can be done for instance in the Shamir Secret Sharing scheme, since N = 256 (8 bits, 1 byte)
(https://github.com/rbaron/secret/blob/master/secret.c#L44).

# Composition of modular congruences

Say we have the two congruences:
f(x) = a1x + b1 (mod N)
g(x) = a2x + b2 (mod N)

fog(x) = a1(a2x + b2) + b1 = a1a2x + a1b2 + b1 (mod N)

# How can we apply the same modular function over and over again?

## Twice
f(f(x)) = a(ax + b) + b = a^2 + ab + b

## Trice
f(f(f(x))) = a^2(ax + b) + ab + b = a^3x + a^2b + ab + b

## Four times
f^4(x) = a^3(ax + b) + a^2b + ab + b = a^4x + a^3b + a^2b + ab + b
       = a^4 + b(a^3 + a^2 + a + 1)

## n times
f^n(x) = a^nx + a^(n-1)b + ... + ab + b
       = a^nx + b(a^(n-1) + a^(n-2) + ... + a + 1)

The part multiplying b is a geometric progression, and its sum is:

(1 - r^n)/(1 - r)

In our case:
n (number of times to run the full inversion) = 101741582076661 (prime)
N (deck size) = 119315717514047 (prime)

So we need to calculate:

## 1st term: a^n

We know that (https://en.wikipedia.org/wiki/Fermat%27s_little_theorem), if p is prime:
a^(p-1) = 1 (mod p)
a^n = a^(n-1) * a = a (mod N)